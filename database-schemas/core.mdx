---
title: "Core Models Schema"
description: "Central marketplace models including tokens, promotions, skills, and business logic"
icon: "database"
---

# Core Models Schema

The core module contains the central business logic models for the Mdadda marketplace, including the token system, promotions, skills taxonomy, and core marketplace functionality.

## Token System

### Token Type Model (`core_tokentype`)

Defines different types of tokens available in the marketplace for various actions.

```sql
CREATE TABLE core_tokentype (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    description TEXT,
    token_type VARCHAR(50) NOT NULL
        CHECK (token_type IN ('like', 'super_like', 'boost', 'incognito', 'premium')),
    base_price DECIMAL(10,2) NOT NULL CHECK (base_price >= 0),
    currency VARCHAR(3) DEFAULT 'KES',
    is_active BOOLEAN DEFAULT TRUE,
    display_order INTEGER DEFAULT 0,
    icon VARCHAR(100),
    color_code VARCHAR(7), -- Hex color code

    -- Metadata
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```

### Promotion Model (`core_promotion`)

Flexible promotion system with JSON configuration for complex promotional logic.

```sql
CREATE TABLE core_promotion (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(200) NOT NULL,
    description TEXT,
    promotion_type VARCHAR(50) NOT NULL
        CHECK (promotion_type IN ('percentage', 'fixed_amount', 'bundle', 'bonus_tokens')),

    -- Configuration stored as JSON for flexibility
    configuration JSONB NOT NULL,
    /*
    Example configurations:
    {
        "discount_percentage": 20,
        "min_purchase_amount": 1000,
        "max_discount": 500
    }
    OR
    {
        "bundle_items": [
            {"token_type_id": "uuid", "quantity": 10},
            {"token_type_id": "uuid", "quantity": 5}
        ],
        "bundle_price": 2000
    }
    */

    -- Validity period
    start_date TIMESTAMP WITH TIME ZONE,
    end_date TIMESTAMP WITH TIME ZONE,
    is_active BOOLEAN DEFAULT TRUE,

    -- Usage limits
    max_uses_per_user INTEGER,
    max_total_uses INTEGER,
    current_total_uses INTEGER DEFAULT 0,

    -- Targeting
    target_user_roles TEXT[] DEFAULT '{}', -- Array of roles
    target_cities TEXT[] DEFAULT '{}', -- Array of cities

    -- Metadata
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,

    -- Constraints
    CHECK (start_date IS NULL OR end_date IS NULL OR start_date < end_date),
    CHECK (max_uses_per_user IS NULL OR max_uses_per_user > 0),
    CHECK (max_total_uses IS NULL OR max_total_uses > 0)
);
```

### Promotion Purchase Model (`core_promopurchase`)

Tracks token purchases with promotional pricing and idempotency.

```sql
CREATE TABLE core_promopurchase (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users_user(id) ON DELETE CASCADE,
    token_type_id UUID NOT NULL REFERENCES core_tokentype(id) ON DELETE PROTECT,
    promotion_id UUID REFERENCES core_promotion(id) ON DELETE SET NULL,

    -- Purchase details
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    unit_price DECIMAL(10,2) NOT NULL CHECK (unit_price >= 0),
    total_amount DECIMAL(10,2) NOT NULL CHECK (total_amount >= 0),
    discount_amount DECIMAL(10,2) DEFAULT 0 CHECK (discount_amount >= 0),
    final_amount DECIMAL(10,2) NOT NULL CHECK (final_amount >= 0),
    currency VARCHAR(3) DEFAULT 'KES',

    -- Payment and status
    payment_method VARCHAR(50),
    payment_reference VARCHAR(255),
    status VARCHAR(20) DEFAULT 'pending'
        CHECK (status IN ('pending', 'completed', 'failed', 'refunded', 'cancelled')),

    -- Idempotency and tracking
    idempotency_key VARCHAR(255) UNIQUE NOT NULL,
    transaction_id VARCHAR(255),

    -- Metadata
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP WITH TIME ZONE,

    -- Ensure final amount calculation is correct
    CHECK (final_amount = total_amount - discount_amount)
);
```

### Subscription Model (`core_subscription`)

Recurring subscription packages for premium features.

```sql
CREATE TABLE core_subscription (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(200) NOT NULL,
    description TEXT,
    subscription_type VARCHAR(50) NOT NULL
        CHECK (subscription_type IN ('monthly', 'quarterly', 'yearly')),

    -- Pricing
    price DECIMAL(10,2) NOT NULL CHECK (price >= 0),
    currency VARCHAR(3) DEFAULT 'KES',

    -- Benefits (JSON configuration)
    benefits JSONB NOT NULL,
    /*
    Example:
    {
        "monthly_tokens": {
            "like": 50,
            "super_like": 10,
            "boost": 5
        },
        "features": ["priority_support", "advanced_analytics", "incognito_mode"],
        "discounts": {
            "additional_tokens": 20
        }
    }
    */

    -- Status
    is_active BOOLEAN DEFAULT TRUE,
    display_order INTEGER DEFAULT 0,

    -- Metadata
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```

### Subscription Purchase Model (`core_subscriptionpurchase`)

Tracks user subscription purchases and renewals.

```sql
CREATE TABLE core_subscriptionpurchase (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users_user(id) ON DELETE CASCADE,
    subscription_id UUID NOT NULL REFERENCES core_subscription(id) ON DELETE PROTECT,

    -- Subscription period
    start_date TIMESTAMP WITH TIME ZONE NOT NULL,
    end_date TIMESTAMP WITH TIME ZONE NOT NULL,
    is_active BOOLEAN DEFAULT TRUE,

    -- Payment details
    amount DECIMAL(10,2) NOT NULL CHECK (amount >= 0),
    currency VARCHAR(3) DEFAULT 'KES',
    payment_method VARCHAR(50),
    payment_reference VARCHAR(255),

    -- Renewal settings
    auto_renew BOOLEAN DEFAULT TRUE,
    renewal_date TIMESTAMP WITH TIME ZONE,

    -- Status tracking
    status VARCHAR(20) DEFAULT 'active'
        CHECK (status IN ('active', 'cancelled', 'expired', 'suspended')),

    -- Metadata
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,

    -- Constraints
    CHECK (start_date < end_date)
);
```

## Skills Taxonomy

### Skill Model (`core_skill`)

Comprehensive skills taxonomy for house helpers.

```sql
CREATE TABLE core_skill (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    skill_name VARCHAR(100) UNIQUE NOT NULL,
    category VARCHAR(50) NOT NULL,
    subcategory VARCHAR(50),
    description TEXT,

    -- Skill metadata
    difficulty_level VARCHAR(20) DEFAULT 'intermediate'
        CHECK (difficulty_level IN ('beginner', 'intermediate', 'advanced', 'expert')),
    time_to_learn_hours INTEGER, -- Estimated learning time
    market_demand VARCHAR(20) DEFAULT 'medium'
        CHECK (market_demand IN ('low', 'medium', 'high', 'very_high')),

    -- Display and search
    keywords TEXT[], -- Array for search optimization
    display_order INTEGER DEFAULT 0,
    icon VARCHAR(100),
    is_featured BOOLEAN DEFAULT FALSE,
    is_active BOOLEAN DEFAULT TRUE,

    -- Metadata
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```

### Skill Category Model (`core_skillcategory`)

Hierarchical categorization of skills.

```sql
CREATE TABLE core_skillcategory (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(100) UNIQUE NOT NULL,
    description TEXT,
    parent_category_id UUID REFERENCES core_skillcategory(id) ON DELETE SET NULL,

    -- Display properties
    icon VARCHAR(100),
    color_code VARCHAR(7),
    display_order INTEGER DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE,

    -- Metadata
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
);
```

## Token Tracking System

### Duffle Source Model (`core_dufflesource`)

Tracks token credits and debits for audit purposes (inspired by double-entry bookkeeping).

```sql
CREATE TABLE core_dufflesource (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id UUID NOT NULL REFERENCES users_user(id) ON DELETE CASCADE,
    token_type_id UUID NOT NULL REFERENCES core_tokentype(id) ON DELETE PROTECT,

    -- Transaction details
    transaction_type VARCHAR(20) NOT NULL
        CHECK (transaction_type IN ('credit', 'debit')),
    amount INTEGER NOT NULL CHECK (amount != 0),
    running_balance INTEGER NOT NULL,

    -- Source tracking
    source_type VARCHAR(50) NOT NULL
        CHECK (source_type IN (
            'purchase', 'promotion_bonus', 'referral_bonus', 'admin_adjustment',
            'like_action', 'super_like_action', 'boost_action', 'gift_sent', 'gift_received'
        )),
    source_id UUID, -- References the source transaction/action
    reference_model VARCHAR(50), -- Model name for the source

    -- Description and metadata
    description TEXT,
    metadata JSONB DEFAULT '{}',

    -- Timestamp
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,

    -- Ensure amount sign matches transaction type
    CHECK (
        (transaction_type = 'credit' AND amount > 0) OR
        (transaction_type = 'debit' AND amount < 0)
    )
);
```

## Gift System

### Gift Model (`core_gift`)

Peer-to-peer token gifting system.

```sql
CREATE TABLE core_gift (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    sender_id UUID NOT NULL REFERENCES users_user(id) ON DELETE CASCADE,
    recipient_id UUID REFERENCES users_user(id) ON DELETE CASCADE,
    token_type_id UUID NOT NULL REFERENCES core_tokentype(id) ON DELETE PROTECT,

    -- Gift details
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    message TEXT,
    gift_code VARCHAR(20) UNIQUE NOT NULL,

    -- Status and timing
    status VARCHAR(20) DEFAULT 'sent'
        CHECK (status IN ('sent', 'redeemed', 'expired', 'cancelled')),
    sent_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    redeemed_at TIMESTAMP WITH TIME ZONE,
    expires_at TIMESTAMP WITH TIME ZONE,

    -- Gift type
    gift_type VARCHAR(20) DEFAULT 'direct'
        CHECK (gift_type IN ('direct', 'code_based', 'anonymous')),

    -- Metadata
    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,

    -- Constraints
    CHECK (sender_id != recipient_id OR recipient_id IS NULL)
);
```

## Indexes and Performance

### Core Indexes

```sql
-- Token type indexes
CREATE INDEX idx_tokentype_active ON core_tokentype(is_active, display_order);
CREATE INDEX idx_tokentype_type ON core_tokentype(token_type);

-- Promotion indexes
CREATE INDEX idx_promotion_active ON core_promotion(is_active);
CREATE INDEX idx_promotion_dates ON core_promotion(start_date, end_date) WHERE is_active = TRUE;
CREATE INDEX idx_promotion_type ON core_promotion(promotion_type);

-- Purchase indexes
CREATE INDEX idx_promopurchase_user ON core_promopurchase(user_id, status);
CREATE INDEX idx_promopurchase_status ON core_promopurchase(status, created_at);
CREATE INDEX idx_promopurchase_token_type ON core_promopurchase(token_type_id);
CREATE INDEX idx_promopurchase_idempotency ON core_promopurchase(idempotency_key);

-- Subscription indexes
CREATE INDEX idx_subscription_active ON core_subscription(is_active, display_order);
CREATE INDEX idx_subscriptionpurchase_user ON core_subscriptionpurchase(user_id, status);
CREATE INDEX idx_subscriptionpurchase_active ON core_subscriptionpurchase(is_active, end_date);
CREATE INDEX idx_subscriptionpurchase_renewal ON core_subscriptionpurchase(auto_renew, renewal_date)
    WHERE status = 'active';

-- Skill indexes
CREATE INDEX idx_skill_category ON core_skill(category, is_active);
CREATE INDEX idx_skill_active ON core_skill(is_active, display_order);
CREATE INDEX idx_skill_featured ON core_skill(is_featured, display_order) WHERE is_active = TRUE;
CREATE INDEX idx_skill_keywords ON core_skill USING GIN(keywords);

-- Token tracking indexes
CREATE INDEX idx_dufflesource_user_token ON core_dufflesource(user_id, token_type_id);
CREATE INDEX idx_dufflesource_created ON core_dufflesource(created_at);
CREATE INDEX idx_dufflesource_source ON core_dufflesource(source_type, source_id);

-- Gift indexes
CREATE INDEX idx_gift_sender ON core_gift(sender_id, status);
CREATE INDEX idx_gift_recipient ON core_gift(recipient_id, status);
CREATE INDEX idx_gift_code ON core_gift(gift_code);
CREATE INDEX idx_gift_expires ON core_gift(expires_at) WHERE status = 'sent';
```

## Common Queries

### Token Purchase Analytics

```sql
-- Token purchase summary by user role
SELECT
    u.role,
    tt.name as token_type,
    COUNT(p.id) as total_purchases,
    SUM(p.quantity) as total_tokens,
    SUM(p.final_amount) as total_revenue,
    AVG(p.final_amount) as avg_purchase_amount
FROM core_promopurchase p
JOIN users_user u ON p.user_id = u.id
JOIN core_tokentype tt ON p.token_type_id = tt.id
WHERE p.status = 'completed'
    AND p.created_at >= CURRENT_DATE - INTERVAL '30 days'
GROUP BY u.role, tt.id, tt.name
ORDER BY total_revenue DESC;

-- User token balance
SELECT
    u.id,
    u.first_name,
    u.last_name,
    tt.name as token_type,
    SUM(ds.amount) as current_balance
FROM users_user u
JOIN core_dufflesource ds ON u.id = ds.user_id
JOIN core_tokentype tt ON ds.token_type_id = tt.id
WHERE u.id = $1
GROUP BY u.id, tt.id, tt.name
HAVING SUM(ds.amount) > 0;
```

### Promotion Effectiveness

```sql
-- Promotion usage and effectiveness
SELECT
    pr.name,
    pr.promotion_type,
    COUNT(p.id) as total_uses,
    SUM(p.discount_amount) as total_discount_given,
    SUM(p.final_amount) as revenue_generated,
    AVG(p.discount_amount) as avg_discount_per_use,
    CASE
        WHEN pr.max_total_uses IS NOT NULL
        THEN (COUNT(p.id)::FLOAT / pr.max_total_uses * 100)
        ELSE NULL
    END as usage_percentage
FROM core_promotion pr
LEFT JOIN core_promopurchase p ON pr.id = p.promotion_id AND p.status = 'completed'
WHERE pr.is_active = TRUE
    AND (pr.end_date IS NULL OR pr.end_date >= CURRENT_DATE)
GROUP BY pr.id, pr.name, pr.promotion_type, pr.max_total_uses
ORDER BY total_uses DESC;
```

### Skills Analytics

```sql
-- Most popular skills by category
SELECT
    s.category,
    s.skill_name,
    COUNT(hhs.househelper_id) as helper_count,
    AVG(CASE WHEN hhs.proficiency_level = 'expert' THEN 4
             WHEN hhs.proficiency_level = 'advanced' THEN 3
             WHEN hhs.proficiency_level = 'intermediate' THEN 2
             ELSE 1 END) as avg_proficiency_score
FROM core_skill s
JOIN househelps_househelper_skills hhs ON s.id = hhs.skill_id
JOIN househelps_househelper hh ON hhs.househelper_id = hh.id
JOIN users_user u ON hh.user_id = u.id
WHERE u.is_active = TRUE
    AND s.is_active = TRUE
GROUP BY s.category, s.skill_name, s.id
ORDER BY s.category, helper_count DESC;
```

## Business Logic Functions

### Token Balance Calculation

```sql
-- Function to get user's current token balance
CREATE OR REPLACE FUNCTION get_user_token_balance(
    p_user_id UUID,
    p_token_type_id UUID
) RETURNS INTEGER AS $$
DECLARE
    balance INTEGER;
BEGIN
    SELECT COALESCE(SUM(amount), 0)
    INTO balance
    FROM core_dufflesource
    WHERE user_id = p_user_id
        AND token_type_id = p_token_type_id;

    RETURN balance;
END;
$$ LANGUAGE plpgsql;

-- Function to debit tokens (returns success/failure)
CREATE OR REPLACE FUNCTION debit_user_tokens(
    p_user_id UUID,
    p_token_type_id UUID,
    p_amount INTEGER,
    p_source_type VARCHAR(50),
    p_source_id UUID DEFAULT NULL,
    p_description TEXT DEFAULT NULL
) RETURNS BOOLEAN AS $$
DECLARE
    current_balance INTEGER;
    new_balance INTEGER;
BEGIN
    -- Get current balance
    current_balance := get_user_token_balance(p_user_id, p_token_type_id);

    -- Check if user has enough tokens
    IF current_balance < p_amount THEN
        RETURN FALSE;
    END IF;

    -- Calculate new balance
    new_balance := current_balance - p_amount;

    -- Insert debit record
    INSERT INTO core_dufflesource (
        user_id, token_type_id, transaction_type, amount,
        running_balance, source_type, source_id, description
    ) VALUES (
        p_user_id, p_token_type_id, 'debit', -p_amount,
        new_balance, p_source_type, p_source_id, p_description
    );

    RETURN TRUE;
END;
$$ LANGUAGE plpgsql;
```

### Promotion Validation

```sql
-- Function to validate if a promotion can be used
CREATE OR REPLACE FUNCTION validate_promotion_usage(
    p_promotion_id UUID,
    p_user_id UUID,
    p_purchase_amount DECIMAL DEFAULT NULL
) RETURNS TABLE(
    is_valid BOOLEAN,
    error_message TEXT
) AS $$
DECLARE
    promo RECORD;
    user_usage_count INTEGER;
BEGIN
    -- Get promotion details
    SELECT * INTO promo
    FROM core_promotion
    WHERE id = p_promotion_id;

    -- Check if promotion exists and is active
    IF promo.id IS NULL THEN
        RETURN QUERY SELECT FALSE, 'Promotion not found';
        RETURN;
    END IF;

    IF NOT promo.is_active THEN
        RETURN QUERY SELECT FALSE, 'Promotion is not active';
        RETURN;
    END IF;

    -- Check date validity
    IF promo.start_date IS NOT NULL AND promo.start_date > CURRENT_TIMESTAMP THEN
        RETURN QUERY SELECT FALSE, 'Promotion has not started yet';
        RETURN;
    END IF;

    IF promo.end_date IS NOT NULL AND promo.end_date < CURRENT_TIMESTAMP THEN
        RETURN QUERY SELECT FALSE, 'Promotion has expired';
        RETURN;
    END IF;

    -- Check total usage limit
    IF promo.max_total_uses IS NOT NULL AND promo.current_total_uses >= promo.max_total_uses THEN
        RETURN QUERY SELECT FALSE, 'Promotion usage limit reached';
        RETURN;
    END IF;

    -- Check per-user usage limit
    IF promo.max_uses_per_user IS NOT NULL THEN
        SELECT COUNT(*)
        INTO user_usage_count
        FROM core_promopurchase
        WHERE promotion_id = p_promotion_id
            AND user_id = p_user_id
            AND status = 'completed';

        IF user_usage_count >= promo.max_uses_per_user THEN
            RETURN QUERY SELECT FALSE, 'User has reached promotion usage limit';
            RETURN;
        END IF;
    END IF;

    -- Check minimum purchase amount (if specified in configuration)
    IF p_purchase_amount IS NOT NULL AND promo.configuration ? 'min_purchase_amount' THEN
        IF p_purchase_amount < (promo.configuration->>'min_purchase_amount')::DECIMAL THEN
            RETURN QUERY SELECT FALSE, 'Purchase amount below promotion minimum';
            RETURN;
        END IF;
    END IF;

    -- All validations passed
    RETURN QUERY SELECT TRUE, 'Promotion is valid'::TEXT;
END;
$$ LANGUAGE plpgsql;
```

## Data Migration Examples

### Token Type Migration

```python
# Django migration for token types
from django.db import migrations

def create_default_token_types(apps, schema_editor):
    TokenType = apps.get_model('core', 'TokenType')

    token_types = [
        {
            'name': 'Like Token',
            'token_type': 'like',
            'base_price': 50.00,
            'description': 'Standard like to show interest'
        },
        {
            'name': 'Super Like Token',
            'token_type': 'super_like',
            'base_price': 150.00,
            'description': 'Priority like that stands out'
        },
        {
            'name': 'Boost Token',
            'token_type': 'boost',
            'base_price': 200.00,
            'description': 'Boost your profile visibility'
        },
        {
            'name': 'Incognito Token',
            'token_type': 'incognito',
            'base_price': 100.00,
            'description': 'Browse profiles anonymously'
        }
    ]

    for token_data in token_types:
        TokenType.objects.get_or_create(
            name=token_data['name'],
            defaults=token_data
        )

class Migration(migrations.Migration):
    dependencies = [
        ('core', '0001_initial'),
    ]

    operations = [
        migrations.RunPython(create_default_token_types),
    ]
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Marketplace Models" href="/database-schemas/marketplace" icon="store">
    Advanced marketplace functionality and transaction models
  </Card>
  <Card title="House Helper Models" href="/database-schemas/househelps" icon="broom">
    House helper profiles and service-specific schemas
  </Card>
  <Card title="Chat Models" href="/database-schemas/chats" icon="message">
    Real-time messaging and conversation schemas
  </Card>
  <Card title="Shortlist Models" href="/database-schemas/shortlist" icon="heart">
    Matching algorithms and user interaction schemas
  </Card>
</CardGroup>